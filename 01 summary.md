1. 常用正则表达式
    一、校验数字的表达式
    1 数字：^[0-9]*$
    2 n位的数字：^\d{n}$
    3 至少n位的数字：^\d{n,}$
    4 m-n位的数字：^\d{m,n}$
    5 零和非零开头的数字：^(0|[1-9][0-9]*)$
    6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
    7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$
    8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
    9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
    10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
    11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$
    12 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$
    13 非负整数：^\d+$ 或 ^[1-9]\d*|0$
    14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
    15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
    16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
    17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
    18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
    19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
    二、校验字符的表达式
    1 汉字：^[\u4e00-\u9fa5]{0,}$
    2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
    3 长度为3-20的所有字符：^.{3,20}$
    4 由26个英文字母组成的字符串：^[A-Za-z]+$
    5 由26个大写英文字母组成的字符串：^[A-Z]+$
    6 由26个小写英文字母组成的字符串：^[a-z]+$
    7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
    8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
    9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
    10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
    11 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+
    12 禁止输入含有~的字符：[^~\x22]+
    三、特殊需求表达式
    1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
    2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
    3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
    4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
    5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 
    6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}
    7 身份证号(15位、18位数字)：^\d{15}|\d{18}$
    8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$
    9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
    10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
    11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$  
    12 日期格式：^\d{4}-\d{1,2}-\d{1,2}
    13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
    14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 
    15 钱的输入格式：
    16    1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 
    17    2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 
    18    3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 
    19    4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 
    20    5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$ 
    21    6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 
    22    7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 
    23    8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 
    24    备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
    25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
    26 中文字符的正则表达式：[\u4e00-\u9fa5]
    27 双字节字符：[^\x00-\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
    28 空白行的正则表达式：\n\s*\r    (可以用来删除空白行)
    29 HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? />    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
    30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
    31 腾讯QQ号：[1-9][0-9]{4,}    (腾讯QQ号从10000开始)
    32 中国邮政编码：[1-9]\d{5}(?!\d)    (中国邮政编码为6位数字)
    33 IP地址：\d+\.\d+\.\d+\.\d+    (提取IP地址时有用)

    密码的： /^[A-Z]{6,18}|[a-z]{6,18}|[0-9]{6,18}$/  只有数字或者字母

    /^([a-z].*[A-Z])|([A-Z].*[a-z])/   有大小写的字母

    /^([a-z].*[0-9])|([A-Z].*[0-9])|[0-9].*[a-zA-Z]/

    /^[A-Za-z0-9]+[_][A-Za-z0-9]*$/  



声明和使用
    @正则的声明和使用
    通过构造函数定义
    var 变量名= new RegExp(/表达式/);
    通过直接量定义（简单方便，我们一般用这个）
    var 变量名= /表达式/;
    常用方法，可用于检测传入的字符串是否符合该规则并返回布尔值
    exp.test("要检测的字符串")
预定义类
    @预定义类和转义符
    .	[^\n\r]	除了换行和回车之外的任意字符
    \d	[0-9]		数字字符digit
    \D	[^0-9]	非数字字符
    \w	[a-zA-Z0-9_]	单词字符(所有的字母数字和_) word
    \W	[^a-zA-Z0-9_]	非单词字符
    \s	[\f\r\n\t\v]	不可见字符 space
    \S	[^\f\r\n\t\v]	可见字符
    转义符
    \f 表示换页 form feed
    \t 表示水平制表符 table
    \v 表示垂直制表符 vertical table
    
    \r,\n,\r\n的区别
        在万恶的旧社会，打字机换行（\n newline）之后只会下移一行，需要回到一行的开头（\r return）才能继续打字
        老式的操作系统也继承了打字机的这一特性，但用户换行之后一般都是要回到开头的，因此新式的操作系统为了方便将键盘上的Enter键的含义修改为\r\n
字符类
    @字符类
    简单类[abc] 表示该位置可以出现的字符
    负向类[^abc] 表示该位置不可以出现的字符
    范围类[a-e]  表示该位置可以出现的字符的范围
    组合类[a-xA-E0-9] 范围类的组合

边界 量词 括号
    @边界
    ^ 会匹配行或者字符串的起始位置
    ^只有在[]内才表示非 在外边表示开始
    $ 会匹配行或字符串的结尾位置
    ^$在一起 表示必须是这个（精确匹配）
    @量词
    "*"	重复零次或更多 x>=0
    "+"	重复一次或更多次 x>=1
    "?"	重复零次或一次  x=(0||1)
    {n}	n次	x=n
    {n,}	重复n次或更多  x>=n
    {n,m} 重复出现的次数比n多但比m少 n<=x<=m
    @括号总结
    ()表示一组
    []表示一个字符的位置
    {}表示次数

常见项目的匹配
    常见项目的匹配网上有很多（例如搜索常用正则表达式大全），无需记忆，能看懂即可
    匹配国内电话号码：
    /^0\d{2,3}-\d{7,8}$/
    匹配姓名：
    /^[\u4e00-\u9fa5]{2,}$/
    匹配腾讯QQ号：
    /^[1-9]\d{4,10}$/
    匹配手机号：
    /^(13[0-9]|14[57]|15[0-9]|18[0-9])\d{8}$/
    匹配邮箱：
    /^\w+([+-.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/

封装自己的trim方法
    replace() 方法     格式:
    字符串对象.replace(正则式或字符串，替换的目标字符)
    用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的字符串
    返回值:
    一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的
    正则表达式的常见匹配模式
    g 全局模式（Global），在匹配时查找所有字符串，而非发现一个就停止
    i 忽略大小写模式（IgnoreCase），在匹配时忽略大小写
    m 多行模式（multiline），在匹配至一行文本末尾后，还会继续匹配下一行
    @封装自己的trim()方法
        function trim(str) {
            return str.replace(/^\s+/,"").replace(/\s+$/,"");
        }
    @使用trim()方法检测用户输入

面向对象：
对象
    数据类型
    基本数据类型 string number boolean null undefined
    复杂数据类型 Object
    什么是对象
    对象其实就是一组数据和功能的集合
    对象可以方便地描述和模拟客观事物

@对象的创建和使用
    通过构造函数声明
    var obj = new Object();    
    通过直接量声明
    var obj = {};

创建对象
    var obj = {};
    obj.name = "刘德华";
    obj.age = 55;
    obj.showName = function () {
        alert("Hi, my name is " + person.name);
    }
    obj.showAge = function () {
        alert("Hi, I'm " + person.age);
    }

使用对象
    console.log(obj.name);  // 调用属性
    console.log(obj.age);
    obj.showName();   //  调用方法
    obj.showAge();

面向对象OOP
    Object Orented Programming 面向对象的程序设计
    因为对象可以方便地描述和模拟客观事物，使项目（尤其是大型项目）的开发能够模块化，便于大规模协同开发和维护，所以面向对象的开发语言和面向对象的程序设计越来越流行，这一点在后面的项目中大家会有深刻的体会。

工厂模式创建对象
    为什么要优化创建对象的方式
    因为对象在项目中被大规模的使用，所以每一点小小的改进都会对项目整体效率带来很大的提升，现阶段同学们还不可能有深刻的体会，只是让大家了解一下，后面讲项目大家自然就明白了。
    @工厂模式
    同类型对象，只是一些属性的值不同，通过对象字面量创建对象每次都要写那么多东西很费劲，我们可以将创建对象的过程封装进一个函数，只把发生变化的属性作为参数传入，从而简化对象创建的过程。
    但是工厂模式只是创建出来一个普通的对象并将其返回，因此无法判断实例的具体类型。

构造函数模式创建对象
    @this和new关键字
    利用new 关键字可以声明新的对象
    new运算符的作用是创建一个对象实例。这个对象可以是用户自定义的，也可以是带构造函数的一些系统自带的对象。
    new 关键字可以让 this 指向新的对象
    @构造函数模式
    所谓"构造函数"，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。这样通过instanceof就可以判断实例的类型了。

原型模式创建对象
    @原型prototype简介
    每个函数都有一个prototype属性，这个属性是指向一个对象的引用，这个对象称为原型对象，原型对象包含函数实例共享的方法和属性，也就是说将函数用作构造函数调用的时候，新创建的对象会从原型对象上继承属性和方法。使用prototype的好处是可以让所有对象实例共享它所包含的属性和方法。

    原型的使用格式：
    类名.prototype.属性名 = 属性值
    类名.prototype.方法名 = function () {}
    可以把那些不变的属性和方法，直接定义在prototype上，这样可以避免创建多个重复方法。

    @原型模式
    主要解决：函数因为使用非常非常多，重复执行效率太低。
    Person.prototype.showName = function() {  // 用的共同的父亲
        alert("我的名字是"+ this.name);
    }

什么是闭包
闭包是指有权访问另一个函数作用域中的变量的函数

@体验闭包
    function outerFun() {
        var a = 0;
        function innerFun() {
            a++;//包的是变量
            alert(a);
        }//这就是个包
        return innerFun;  //注意这里
    }
    var obj = outerFun();
    obj(); obj();
    var obj2 = outerFun();
    obj2(); obj2();
    函数变量被隐藏在作用域链内，看起来就像是函数将变量包裹了起来（所以叫闭包）（闭包包的是变量）

    函数的内部变量是局部变量，局部变量一般是不可以被别人随便使用的
    @局部变量外部不可用
    但是如果另一个函数在这个函数的作用域链内，就可以访问了
    @函数作用域链内可用
    我们可以通过将函数作用域链内的函数返回的形式，让外部访问该函数内部的变量
    @抛出函数作用域链内的函数

闭包的应用
    闭包的主要应用就是特权方法，特权方法能够让外界对函数内部的私有变量进行受限制的访问。这一特性在某些项目的开发中会非常常见。
    @通过特权方法访问私有变量
    有时候有些属性不能直接暴露给外界直接访问，例如OA系统中的工资，只能本人才能查看这时我们需要将工资这个属性设置为私有变量，并让外界通过特权方法进行有条件的访问。
闭包的优点 ： 
    优点：不产生全局变量，实现属性私有化。
    缺点：闭包中的数据会常驻内存，在不用的时候要手动删除，否则会导致内存溢出。




offset系列
    offsetWidth和offsetHeight
        用来得到对象的大小
    @offsetHeight和style.height的区别
        style.height是字符串，offsetHeight是数值
        demo.style.height是用来获取和设置行内样式的，offsetHeight是只读属性
        demo.style.height只能获取和设置行内样式，如果样式写到了其他地方，甚至根本就没写，便无法获取
        因此，工作中一般用demo.offsetHeight来获取某元素的真实宽度/高度，用style.height来设置宽度/高度
    @offsetHeight的构成
        offsetHeight = height+padding+border
        包括 自身高度 内边距 边框 不包括 外边距

offsetLeft和offsetTop
    用来得到对象的位置（注意：没有offsetRight和offsetBottom）
@offsetLeft的构成
    到最近的（带有定位的）父元素的 左侧/顶部 的距离
    如果所有父级都没有定位则以body 为准
    offsetLeft 是自身border左侧到父级padding左侧的距离
    

@offsetLeft和style.left的区别
    一、style.left只能获取行内样式
    二、offsetLeft只读，style.left可读可写
    三、offsetLeft是数值，style.left是字符串并且有单位px
    四、如果没有加定位，style.left获取的数值可能是无效的
    五、最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准

offsetParent
    @offsetParent爸爸去哪
    返回该对象距离最近的带有定位的父级
    如果当前元素的所有父级元素都没有定位（position为absolute或relative），offsetParent为body
    如果当前元素的父级元素中有定位（position为absolute或relative），offsetParent取最近的那个父级元素
    另外注意offsetParent与parentNode的区别parentNode只找自己的上一级（亲爹）


不用死记，offset是计算偏移的，要算都算要不算都不算，只要记住和定位有关就行了，margin、border、padding要算都算要不算都不算，实在需要区分，用的时候自己写个div试一试或者网上一查就知道了。

Math对象
    @Math对象常用方法
    天花板 向上取整 负数取更大的
    Math.ceil(x)
    地板 向下取整 负数取更小的
    Math.floor(x)
    就近取整 四舍五入
    Math.round(x)
    取绝对值
    Math.abs(x)

动画原理
    @体验页面动画
动画原理公式
    动画原理公式：  leader = leader + step
    leader表示盒子当前位置
    step表示步长
    box.style.left = box.offsetLeft + 10 + "px";
    让setInterval不断执行某个函数修改盒子的位置属性最后就实现了动画的效果
动画函数封装
    @动画函数封装
    动画函数较为复杂，却又很常用对于这样的函数，我们一般都会进行封装
    需求：能够让任意对象移动到指定位置。
动画函数改进
    @动画函数改进
    然而封装之后的函数还有很多问题，所以我们要对其进行进一步改进
    判断运动方向
    完善终点检测
    终点清除定时器
    手动设置对象位置到终点
    调用开始先清理定时器，防止多次调用





